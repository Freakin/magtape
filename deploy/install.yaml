apiVersion: v1
kind: Namespace
metadata:
  name: magtape-system

---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: magtape-write
  labels:
    app: magtape
rules:
- apiGroups:
  - admissionregistration.k8s.io
  - certificates.k8s.io
  - events.k8s.io
  - ""
  resources:
    - validatingwebhookconfigurations
    - certificatesigningrequests
    - certificatesigningrequests/approval
    - certificatesigningrequests/status
    - events
    - signers
  verbs:
    - get
    - list
    - watch
    - create
    - patch
    - update
    - delete
    - approve

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: magtape-read
  labels:
    app: magtape
rules:
- apiGroups:
  - ""
  resources:
  - namespaces
  - pods
  - services
  - configmaps
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - apps
  - extensions
  resources:
  - deployments
  - daemonsets
  - statefulsets
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - policy
  resources:
  - poddisruptionbudgets
  verbs:
  - get
  - list
  - watch

---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: magtape-write-crb
  labels:
    app: magtape
roleRef:
  kind: ClusterRole
  name: magtape-write
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: magtape-sa
  namespace: magtape-system

---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: magtape-read-crb
  labels:
    app: magtape
roleRef:
  kind: ClusterRole
  name: magtape-read
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: magtape-sa
  namespace: magtape-system
---
# Define role for OPA/kube-mgmt to update configmaps with policy status.
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: magtape-ops
  namespace: magtape-system
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - list
  - watch
  - create
  - patch
  - update
  - delete
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - watch
  - patch
  - update

---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: magtape-ops-rb
  namespace: magtape-system
roleRef:
  kind: Role
  name: magtape-ops
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: magtape-sa
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: magtape-sa
  namespace: magtape-system
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: magtape-env
  namespace: magtape-system
data:
  FLASK_ENV: "production"
  PYTHONUNBUFFERED: "TRUE"
  MAGTAPE_CLUSTER_NAME: "test-cluster"
  MAGTAPE_LOG_LEVEL: "INFO"
  MAGTAPE_DENY_LEVEL: "LOW"
  MAGTAPE_K8S_EVENTS_ENABLED: "TRUE"
  MAGTAPE_SLACK_ENABLED: "FALSE"
  MAGTAPE_SLACK_PASSIVE: "FALSE"
  MAGTAPE_SLACK_WEBHOOK_URL_DEFAULT: "https://hooks.slack.com/services/XXXXXXXX/XXXXXXXX/XXXXXXXXXXXXXXXXXX"
  MAGTAPE_SLACK_ANNOTATION: "magtape/slack-webhook-url"
  MAGTAPE_SLACK_USER: "mtbot"
  MAGTAPE_SLACK_ICON: ":magtape:"
  OPA_BASE_URL: "http://127.0.0.1:8181"
  OPA_K8S_PATH: "/v0/data/magtape"
---
apiVersion: v1
data:
  magtape-vwc: "apiVersion: admissionregistration.k8s.io/v1beta1\r\nkind: ValidatingWebhookConfiguration\r\nmetadata:\r\n
    \ name: magtape-webhook\r\nwebhooks:\r\n  - name: magtape.webhook.k8s.t-mobile.com\r\n
    \   clientConfig:\r\n      service:\r\n        name: magtape-svc\r\n        namespace:
    magtape-system\r\n        path: \"/\"\r\n      caBundle:\r\n    failurePolicy:
    Fail\r\n    rules:\r\n      - operations:\r\n          - CREATE\r\n          -
    UPDATE\r\n        apiGroups:\r\n          - \"*\"\r\n        apiVersions:\r\n
    \         - \"*\"\r\n        resources:\r\n          - \"deployments\"\r\n          -
    \"statefulsets\"\r\n          - \"daemonsets\"\r\n          - \"pods\"\r\n          -
    \"poddisruptionbudgets\"\r\n    namespaceSelector:\r\n      matchLabels:\r\n        k8s.t-mobile.com/magtape:
    \"enabled\"\r\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: magtape-vwc-template
  namespace: magtape-system

---
kind: ConfigMap
apiVersion: v1
metadata:
  name: magtape-opa-default-main
  namespace: magtape-system
data:
  main: |
    package system

    import data.kubernetes.admission

    main = {
      "apiVersion": "admission.k8s.io/v1beta1",
      "kind": "AdmissionReview",
      "response": response,
    }

    default response = {"allowed": true}

    response = {
        "allowed": false,
        "status": {
            "reason": reason,
        },
    } {
        reason = concat(", ", admission.deny)
        reason != ""
    }
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: magtape-opa-entrypoint
  namespace: magtape-system
  labels:
    app: opa
    openpolicyagent.org/policy: rego

data:
  magtape.rego: |-
    package magtape

    # This acts as an entrypoint to call all policies under "kubernetes.admission"

    decisions[{"policy": p, "reasons": reasons}] {

      data.kubernetes.admission[p].matches
      reasons := data.kubernetes.admission[p].deny

    }

---
apiVersion: v1
kind: Service
metadata:
  name: magtape-svc
  labels:
    app: magtape
  namespace: magtape-system
spec:
  ports:
  - name: https
    port: 443
    targetPort: 5000
  selector:
    app: magtape
  sessionAffinity: None
  type: ClusterIP

---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: magtape-pdb
  namespace: magtape-system
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: magtape
---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: magtape
  namespace: magtape-system
  labels:
    app: magtape
spec:
  replicas: 3
  selector:
    matchLabels:
      app: magtape
  template:
    metadata:
      labels:
        app: magtape
    spec:
      serviceAccountName: magtape-sa
      initContainers:
        - name: magtape-init
          image: tmobile/magtape-init:v2.1.4
          command: [/app/magtape-init.py]
          imagePullPolicy: Always
          env:
          - name: MAGTAPE_POD_NAME
            valueFrom:
              fieldRef:
                fieldPath: metadata.name
          - name: MAGTAPE_NAMESPACE_NAME
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          envFrom:
            - configMapRef:
                name: magtape-env
          volumeMounts:
          - name: magtape-tls
            mountPath: /tls
          - name: magtape-vwc
            mountPath: /vwc
      containers:
      - name: magtape
        image: tmobile/magtape:v2.1.4
        ports:
        - containerPort: 5000
        command: ["gunicorn", "magtape:app", "--config=config.py"]
        imagePullPolicy: Always
        livenessProbe:
          httpGet:
            scheme: HTTPS
            port: 5000
            path: /healthz
          initialDelaySeconds: 3
          periodSeconds: 5
        readinessProbe:
          httpGet:
            scheme: HTTPS
            port: 5000
            path: /healthz
          initialDelaySeconds: 3
          periodSeconds: 5
        resources:
          limits:
            cpu: "1"
            memory: 1Gi
          requests:
            cpu: 50m
            memory: 128Mi
        env:
        - name: MAGTAPE_POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: MAGTAPE_NAMESPACE_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        envFrom:
        - configMapRef:
            name: magtape-env
        volumeMounts:
          - name: magtape-tls
            mountPath: /tls
      - name: opa
        image: openpolicyagent/opa:0.19.2
        args:
          - "run"
          - "--server"
          - "--tls-cert-file=/tls/cert.pem"
          - "--tls-private-key-file=/tls/key.pem"
          - "--addr=0.0.0.0:443"
          - "--addr=http://127.0.0.1:8181"
        readinessProbe:
          httpGet:
            scheme: HTTPS
            port: 443
            path: /health
          initialDelaySeconds: 3
          periodSeconds: 5
        livenessProbe:
          httpGet:
            scheme: HTTPS
            port: 443
            path: /health
          initialDelaySeconds: 3
          periodSeconds: 5
        resources:
          limits:
            cpu: "500m"
            memory: 1Gi
          requests:
            cpu: 50m
            memory: 128Mi
        volumeMounts:
          - name: magtape-tls
            mountPath: /tls
      - name: kube-mgmt
        image: openpolicyagent/kube-mgmt:0.11
        args:
          - "--policies=magtape-system"
          - "--require-policy-label=true"
        resources:
          limits:
            cpu: 500m
            memory: 1Gi
          requests:
            cpu: 50m
            memory: 128Mi
      volumes:
        - name: magtape-vwc
          configMap:
              name: magtape-vwc-template
              items:
              - key: magtape-vwc
                path: magtape-vwc.yaml
        - name: magtape-tls
          emptyDir: {}
      terminationGracePeriodSeconds: 5

---

apiVersion: v1
data:
  policy-emptydir-check.rego: "package kubernetes.admission.policy_emptydir\r\n\r\npolicy_metadata
    = {\r\n\r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-emptydir\",\r\n
    \   \"severity\": \"MED\",\r\n    \"errcode\": \"MT1009\",\r\n    \"targets\":
    {\"Pod\"},\r\n\r\n}\r\n\r\nkind = input.request.kind.kind\r\nsizeLimit = 100\r\n\r\nmatches
    {\r\n\r\n    # Verify request object type matches targets\r\n    policy_metadata.targets[kind]\r\n
    \   \r\n}\r\n\r\ndeny[info] {\r\n\r\n    # Find volume spec\r\n    volumes :=
    input.request.object.spec.volumes\r\n    exceed_err_msg := sprintf(\"is greater
    than %v Megabytes\", [sizeLimit])\r\n\r\n    # Checks emptydir configuration\r\n
    \   volume := volumes[_]\r\n    name := volume.name\r\n    emptydir_state := check_emptydir(volume,
    exceed_err_msg, sizeLimit)\r\n\r\n    # Build message to return\r\n    msg :=
    sprintf(\"[FAIL] %v - Size limit of emptyDir volume \\\"%v\\\" %v (%v)\", [policy_metadata.severity,
    name, emptydir_state, policy_metadata.errcode])\r\n\r\n    info := {\r\n\t\t\r\n
    \       \"name\": policy_metadata.name,\r\n        \"severity\": policy_metadata.severity,\r\n
    \       \"errcode\": policy_metadata.errcode,\r\n        \"msg\": msg,\r\n\r\n
    \   }\r\n    \r\n}\r\n\r\n# check_emptydir accepts three values (volume, exceed_err_msg,
    sizeLimit) \r\n# returns whether there the sizeLimit configuration for emptyDir
    is present, in megaBytes, and below the sizeLimit set above\r\ncheck_emptydir(volume,
    exceed_err_msg, sizeLimit) = \"is not set\" {\r\n\t\r\n    volume.emptyDir\r\n
    \   not volume.emptyDir.sizeLimit\r\n    \r\n} else = \"is not in Megabytes\"
    {\r\n\r\n    volume.emptyDir.sizeLimit\r\n    not endswith(trim_space(volume.emptyDir.sizeLimit),
    \"M\")\r\n    \r\n} else = exceed_err_msg {\r\n\r\n    volume.emptyDir.sizeLimit\r\n
    \   limit := to_number(trim(trim_space(volume.emptyDir.sizeLimit), \"M\"))\r\n
    \   limit > sizeLimit\r\n    \r\n}\r\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-emptydir-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-host-path-check.rego: "package kubernetes.admission.policy_host_path\r\n\r\npolicy_metadata
    = {\r\n\r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-host-path\",\r\n
    \   \"severity\": \"MED\",\r\n    \"errcode\": \"MT1010\",\r\n    \"targets\":
    {\"Pod\"},\r\n\r\n}\r\n\r\nkind = input.request.kind.kind\r\n\r\nmatches {\r\n\r\n
    \   # Verify request object type matches targets\r\n    policy_metadata.targets[kind]\r\n
    \   \r\n}\r\n\r\ndeny[info] {\r\n\r\n    # Find volume spec\r\n    volumes :=
    input.request.object.spec.volumes\r\n\r\n    # Check for hostPath in each volume
    spec\r\n    volume := volumes[_]\r\n    name := volume.name\r\n\thostpath_state
    := check_hostpath(volume)\r\n\r\n    # Build message to return\r\n    msg := sprintf(\"[FAIL]
    %v - %v for volume \\\"%v\\\" (%v)\", [policy_metadata.severity, hostpath_state,
    name, policy_metadata.errcode])\r\n\r\n    info := {\r\n\t\t\r\n        \"name\":
    policy_metadata.name,\r\n        \"severity\": policy_metadata.severity,\r\n        \"errcode\":
    policy_metadata.errcode,\r\n        \"msg\": msg,\r\n\r\n    }\r\n    \r\n}\r\n\r\n#
    check_hostpath accepts a value (volume)\r\n# returns whether there is a hostPath
    configured in the volume\r\ncheck_hostpath(volume) = \"hostPath is configured\"
    {\r\n\t\r\n\tvolume.hostPath\r\n    \r\n}\r\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-host-path-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-host-port-check.rego: "package kubernetes.admission.policy_hostport\r\n\r\npolicy_metadata
    = {\r\n\r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-hostport\",\r\n
    \   \"severity\": \"HIGH\",\r\n    \"errcode\": \"MT1008\",\r\n    \"targets\":
    {\"Pod\"},\r\n\r\n}\r\n\r\nkind = input.request.kind.kind\r\n\r\nmatches {\r\n\r\n
    \   # Verify request object type matches targets\r\n    policy_metadata.targets[kind]\r\n\r\n}\r\n\r\ndeny[info]
    {\r\n\r\n    # Find container spec\r\n    # Since only target is Pod, containers
    will always be found in same place\r\n    containers := input.request.object.spec.containers\r\n\r\n
    \   # Check for hostPort in each container spec\r\n    container := containers[_]\r\n
    \   name := container.name\r\n    port_present := check_hostport(container)\r\n\r\n
    \   # Build message to return\r\n    msg := sprintf(\"[FAIL] %v - %v for container
    \\\"%v\\\" (%v)\", [policy_metadata.severity, port_present, name, policy_metadata.errcode])\r\n\r\n
    \   info := {\r\n\r\n        \"name\": policy_metadata.name,\r\n        \"severity\":
    policy_metadata.severity,\r\n        \"errcode\": policy_metadata.errcode,\r\n
    \       \"msg\": msg,\r\n\r\n    }\r\n\r\n}\r\n\r\n# check_hostport accepts a
    value (container) \r\n# returns whether the hostPort is found in config\r\ncheck_hostport(container)
    = \"hostPort is configured\" {\r\n\r\n    ports := container.ports[_]\r\n    ports.hostPort\r\n\r\n}\r\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-host-port-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-liveness-probe-check.rego: "package kubernetes.admission.policy_liveness_probe\r\n\r\npolicy_metadata
    = {\r\n\r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-liveness-probe\",\r\n
    \   \"severity\": \"LOW\",\r\n    \"errcode\": \"MT1001\",\r\n    \"targets\":
    {\"Deployment\", \"StatefulSet\", \"DaemonSet\", \"Pod\"},\r\n\r\n}\r\n\r\nservicetype
    = input.request.kind.kind\r\n\r\nmatches {\r\n\r\n    # Verify request object
    type matches targets\r\n    policy_metadata.targets[servicetype]\r\n    \r\n}\r\n\r\ndeny[info]
    {\r\n\r\n    # Find container spec\r\n    containers := find_containers(servicetype,
    policy_metadata)\r\n\r\n    # Check for livenessProbe in each container spec\r\n
    \   container := containers[_]\r\n    name := container.name\r\n    not container.livenessProbe\r\n\r\n
    \   # Build message to return\r\n    msg = sprintf(\"[FAIL] %v - Liveness Probe
    missing for container \\\"%v\\\" (%v)\", [policy_metadata.severity, name, policy_metadata.errcode])\r\n\r\n
    \   info := {\r\n        \r\n    \t\"name\": policy_metadata.name,\r\n\t\t\"severity\":
    policy_metadata.severity,\r\n        \"errcode\": policy_metadata.errcode,\r\n\t\t\"msg\":
    msg,\r\n    }\r\n}\r\n\r\n# find_containers accepts a value (k8s object type)
    and returns the container spec\r\nfind_containers(type, metadata) = input.request.object.spec.containers
    {\r\n\r\n    type == \"Pod\"\r\n\r\n} else = input.request.object.spec.template.spec.containers
    {\r\n\r\n\tmetadata.targets[type]\r\n    \r\n}"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-liveness-probe-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-node-port-range-check.rego: "package kubernetes.admission.policy_nodeport_range\r\n\r\nimport
    data.kubernetes.namespaces\r\n\r\npolicy_metadata = {\r\n\r\n    # Set MagTape
    Policy Info\r\n    \"name\": \"policy-nodeport-range\",\r\n    \"severity\": \"MED\",\r\n
    \   \"errcode\": \"MT2002\",\r\n    \"targets\": {\"Service\"},\r\n\r\n}\r\n\r\nkind
    = input.request.kind.kind\r\nsvc_type = input.request.object.spec.type\r\nexception_val
    = \"na\"\r\n\r\nmatches {\r\n\r\n    # Verify request object type matches targets\r\n
    \   # Verify service is of type NodePort\r\n    policy_metadata.targets[kind]\r\n
    \   svc_type == \"NodePort\"\r\n\r\n}\r\n\r\n# Generate violation if nodePort
    Range is not within allocated range\r\ndeny[info] {\r\n\r\n    # ns_name: namespace
    connected to service trying to be deployed\r\n    # ports: where the hostport
    config is found within the service\r\n    # np_range: pull the information connected
    to the nodeportRange label in the namespace yaml config\r\n    ns_name := input.request.namespace\r\n
    \   service_name := input.request.object.metadata.name\r\n    ports := input.request.object.spec.ports\r\n\r\n
    \   port := ports[_]\r\n    np := port.nodePort\r\n    np_range := data.kubernetes.namespaces[ns_name].metadata.annotations[\"k8s.t-mobile.com/nodeportRange\"]\r\n
    \   port_in_range := check_nodeport_range(np, np_range)\r\n\r\n    # Build message
    to return\r\n    msg := sprintf(\"[FAIL] %v - nodePort %v %v for Service \\\"%v\\\"
    (%v)\", [policy_metadata.severity, np, port_in_range, service_name, policy_metadata.errcode])\r\n\r\n
    \   info := {\r\n\r\n        \"name\": policy_metadata.name,\r\n        \"severity\":
    policy_metadata.severity,\r\n        \"errcode\": policy_metadata.errcode,\r\n
    \       \"msg\": msg,\r\n\r\n    }\r\n}\r\n\r\n# Generate violation if annotation
    contains anything besides #, commas, hyphen, or exception_val\r\ndeny[info] {\r\n\r\n
    \   # ns_name: namespace connected to service trying to be deployed\r\n    # ports:
    where the hostport config is found within the service\r\n    # np_range: pull
    the information connected to the nodeportRange label in the namespace yaml config\r\n
    \   ns_name := input.request.namespace\r\n    service_name := input.request.object.metadata.name\r\n
    \   ports := input.request.object.spec.ports\r\n\r\n    port := ports[_]\r\n    np_range
    := data.kubernetes.namespaces[ns_name].metadata.annotations[\"k8s.t-mobile.com/nodeportRange\"]\r\n
    \   annotation_valid := check_annotation(np_range, exception_val)\r\n\r\n\r\n
    \   # Build message to return\r\n    msg := sprintf(\"[FAIL] %v - Invalid data
    in nodePort annotation in \\\"%v\\\" namespace (%v)\", [policy_metadata.severity,
    ns_name, policy_metadata.errcode])\r\n    info := {\r\n\r\n        \"name\": policy_metadata.name,\r\n
    \       \"severity\": policy_metadata.severity,\r\n        \"errcode\": policy_metadata.errcode,\r\n
    \       \"msg\": msg,\r\n\r\n    }\r\n\r\n}\r\n\r\n# Check_annotation accepts
    two values (np, np_range)\r\n# Returns whether the nodeport range contains unknown
    symbols and is not the exception value\r\ncheck_annotation(np_range, exception_val)
    {\r\n\r\n    not re_match(`^[-, ]*[0-9 ]+(?:-[0-9 ]+)?(,[0-9 ]+(?:-[0-9 ]+)?)*[-,
    ]*$`, trim_space(np_range))\r\n    lower(trim_space(np_range)) != exception_val\r\n\r\n}\r\n\r\n\r\n#
    Check_nodeport_range accepts two values (np, np_range) \r\n# Returns whether the
    nodeport(np) is within the range(np_range)\r\ncheck_nodeport_range(np, np_range)
    = \"is out of defined range\" {\r\n\r\n    contains(np_range, \"-\")\r\n    contains(np_range,
    \",\")\r\n    re_match(`^[-, ]*[0-9 ]+(?:-[0-9 ]+)?(,[0-9 ]+(?:-[0-9 ]+)?)*[-,
    ]*$`, trim_space(np_range))\r\n    range_split := split(np_range, \",\")\r\n    not
    range_matches_any(np, range_split)\r\n    \r\n} else = \"is out of defined range\"
    {\r\n\r\n    contains(np_range, \"-\")\r\n    not contains(np_range, \",\")\r\n
    \   re_match(`^[-, ]*[0-9 ]+(?:-[0-9 ]+)?(,[0-9 ]+(?:-[0-9 ]+)?)*[-, ]*$`, trim_space(np_range))\r\n
    \   not range_matches(np, np_range)\r\n\r\n} else = \"is out of defined range\"
    {\r\n\t\r\n    contains(np_range, \",\")\r\n    not contains(np_range, \"-\")\r\n
    \   re_match(`^[-, ]*[0-9 ]+(?:-[0-9 ]+)?(,[0-9 ]+(?:-[0-9 ]+)?)*[-, ]*$`, trim_space(np_range))\r\n
    \   range_split := split(np_range, \",\")\r\n    not range_matches_any(np, range_split)\r\n\r\n}
    \ else = \"is out of defined range\" {\r\n\r\n    not contains(np_range, \",\")\r\n
    \   not contains(np_range, \"-\")\r\n    re_match(`^\\d+$`, trim_space(np_range))\r\n
    \   to_number(trim_space(np_range)) != to_number(np)\r\n\r\n}\r\n\r\nrange_matches_any(npNum,
    list) {\r\n    range_matches(npNum, list[_])\r\n}\r\n\r\n# Checks if nodePort
    is in comma separated list\r\nrange_matches(npNum, list) {\r\n    not contains(list,
    \"-\")\r\n    not contains(list, \",\")\r\n    count(trim_space(list)) > 0\r\n\r\n
    \   to_number(trim_space(list)) == to_number(npNum)\r\n}\r\n\r\n# Checks if nodePort
    is within range\r\nrange_matches(npNum, list) {\r\n    contains(list, \"-\")\r\n
    \   range_split := split(list, \"-\")\r\n    count(trim_space(range_split[0]))
    > 0\r\n    count(trim_space(range_split[1])) > 0\r\n\r\n    to_number(npNum) >=
    to_number(trim_space(range_split[0]))\r\n    to_number(npNum) <= to_number(trim_space(range_split[1]))\r\n}\r\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-node-port-range-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-pdb-check.rego: "package kubernetes.admission.policy_pdb\r\n\r\npolicy_metadata
    = {\r\n\r\n\t# Set MagTape Policy Info\r\n\t\"name\": \"policy-pdb\",\r\n\t\"severity\":
    \"HIGH\",\r\n\t\"errcode\": \"MT1005\",\r\n\t\"targets\": {\"PodDisruptionBudget\"},\r\n\r\n}\r\n\r\nservicetype
    = input.request.kind.kind\r\n\r\nmatches {\r\n\r\n    # Verify request object
    type matches targets\r\n    policy_metadata.targets[servicetype]\r\n    \r\n}\r\n\r\nlimits
    = {\r\n\r\n\t\"minAvailable\": [0, 66],\r\n    \"maxUnavailable\": [33, 100],\r\n\t\r\n}\r\n\r\n#
    Generates a violation if the input doesn't specify a percentage (e.g., they used
    an absolute.)\r\ndeny[info] {\r\n\r\n\t# Get limit type\r\n\tlimits[name]\r\n\r\n
    \   # Get limit value\r\n\tvalue := input.request.object.spec[name]\r\n\r\n  \t#
    Verify the value is a percentage\r\n\t[_, false] = get_percentage(value)\r\n\r\n
    \   msg := sprintf(\"[FAIL] %v - Value \\\"%v\\\" for \\\"%v\\\" should be a Percentage,
    not an Integer (%v)\", [policy_metadata.severity, value, name, policy_metadata.errcode])\r\n\r\n\tinfo
    := {\r\n\r\n    \t\"name\": policy_metadata.name,\r\n\t\t\"severity\": policy_metadata.severity,\r\n
    \       \"errcode\": policy_metadata.errcode,\r\n\t\t\"msg\": msg,\r\n\r\n    }\r\n\r\n}\r\n\r\n#
    Generates a violation if the input specifes a percentage out-of-range.\r\ndeny[info]
    {\r\n\r\n    # Get limit range\r\n\trange := limits[name]\r\n\r\n\t# Get the percentage
    value\r\n    [percent, true] = get_percentage(input.request.object.spec[name])\r\n\r\n
    \   # Verify the percentage is within range\r\n\tnot within_range(percent, range)\r\n\r\n
    \   msg := sprintf(\"[FAIL] %v - Value (%v%%) for \\\"%v\\\" not within range
    %v%%-%v%% (%v)\", [policy_metadata.severity, percent, name, range[0], range[1],
    policy_metadata.errcode])\r\n\r\n\tinfo := {\r\n\r\n        \"name\": policy_metadata.name,\r\n
    \       \"severity\": policy_metadata.severity,\r\n        \"errcode\": policy_metadata.errcode,\r\n
    \       \"msg\": msg,\r\n\r\n    }\r\n\r\n}\r\n\r\nwithin_range(x, [_min, _max])
    {\r\n\r\n\tx >= _min\r\n    x <= _max\r\n\r\n}\r\n\r\n# get_percentage accepts
    a value and generates a tuple containing the \r\n# numeric percentage value and
    a boolean value indicating whether the\r\n# input value could be converted to
    a numeric percentage.\r\n#\r\n# Examples:\r\n#\r\n#   get_percentage(50) == [0,
    false]\r\n#   get_percentage(\"50\") == [0, false]\r\n#   get_percentage(\"50%\")
    == [50, true]\r\nget_percentage(value) = [0, false] {\r\n\r\n\tnot is_string(value)\r\n\r\n}
    else = [0, false] {\r\n\r\n\tnot contains(value, \"%\")\r\n\r\n} else = [percent,
    true] {\r\n\r\n\tpercent := to_number(trim(value, \"%\"))\r\n\r\n}"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-pdb-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-port-name-mismatch.rego: "package kubernetes.admission.policy_port_name_mismatch\r\n\r\npolicy_metadata
    = {\r\n    \r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-port-name-mismatch\",\r\n
    \   \"severity\": \"HIGH\",\r\n    \"errcode\": \"MT1006\",\r\n    \"targets\":
    {\"Service\"},\r\n\r\n}\r\n\r\nservicetype = input.request.kind.kind\r\nsvc_name
    := input.request.object.metadata.name\r\n\r\nmatches {\r\n\r\n    # Verify request
    object type matches targets\r\n    policy_metadata.targets[servicetype]\r\n    \r\n}\r\n\r\ndeny[info]
    {\r\n\r\n    # Find service ports\r\n    ports := input.request.object.spec.ports\r\n\r\n
    \   # Check all port spec's\r\n    port := ports[_]\r\n    port_name := port.name\r\n
    \   port_number := port.port\r\n\r\n    # Check for mismatch between logical port
    name and port number in service spec\r\n    port_name == \"http\"\r\n    port_number
    == 443\r\n\r\n    msg = sprintf(\"[FAIL] %v - Logical port name \\\"%v\\\" mismatch
    with port number \\\"%v\\\" for service \\\"%v\\\" (%v)\", [policy_metadata.severity,
    port_name, port_number, svc_name, policy_metadata.errcode])\r\n\r\n    info :=
    {\r\n\r\n        \"name\": policy_metadata.name,\r\n        \"severity\": policy_metadata.severity,\r\n
    \       \"errcode\": policy_metadata.errcode,\r\n        \"msg\": msg,\r\n\r\n
    \   }\r\n\r\n}"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-port-name-mismatch
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-privileged-pod-check.rego: "package kubernetes.admission.policy_privileged_pod\r\n\r\npolicy_metadata
    = {\r\n    \r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-privileged-pod\",\r\n
    \   \"severity\": \"HIGH\",\r\n    \"errcode\": \"MT2001\",\r\n    \"targets\":
    {\"Deployment\", \"StatefulSet\", \"DaemonSet\", \"Pod\"},\r\n\r\n}\r\n\r\nservicetype
    = input.request.kind.kind\r\n\r\nmatches {\r\n\r\n    # Verify request object
    type matches targets\r\n    policy_metadata.targets[servicetype]\r\n    \r\n}\r\n\r\ndeny[info]
    {\r\n\r\n    # Find container spec\r\n    containers := find_containers(servicetype,
    policy_metadata)\r\n\r\n    # Check for Privileged SecurityContext in container
    spec\r\n    container := containers[_]\r\n    name := container.name\r\n    container.securityContext.privileged\r\n\r\n
    \   msg = sprintf(\"[FAIL] %v - Found privileged Security Context for container
    \\\"%v\\\" (%v)\", [policy_metadata.severity, name, policy_metadata.errcode])\r\n\r\n
    \   info := {\r\n\r\n        \"name\": policy_metadata.name,\r\n        \"severity\":
    policy_metadata.severity,\r\n        \"errcode\": policy_metadata.errcode,\r\n
    \       \"msg\": msg,\r\n\r\n    }\r\n\r\n}\r\n\r\n# find_containers accepts a
    value (k8s object type) and returns the container spec\r\nfind_containers(type,
    metadata) = input.request.object.spec.containers {\r\n\r\n    type == \"Pod\"\r\n\r\n}
    else = input.request.object.spec.template.spec.containers {\r\n\r\n\tmetadata.targets[type]\r\n
    \   \r\n}"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-privileged-pod-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-readiness-probe-check.rego: "package kubernetes.admission.policy_readiness_probe\r\n\r\npolicy_metadata
    = {\r\n\r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-readiness-probe\",\r\n
    \   \"severity\": \"LOW\",\r\n    \"errcode\": \"MT1002\",\r\n    \"targets\":
    {\"Deployment\", \"StatefulSet\", \"DaemonSet\", \"Pod\"},\r\n\r\n}\r\n\r\nservicetype
    = input.request.kind.kind\r\n\r\nmatches {\r\n\r\n    # Verify request object
    type matches targets\r\n    policy_metadata.targets[servicetype]\r\n    \r\n}\r\n\r\ndeny[info]
    {\r\n\r\n    # Find container spec\r\n    containers := find_containers(servicetype,
    policy_metadata)\r\n\r\n    # Check for ReadinessProbe in each container spec\r\n
    \   container := containers[_]\r\n    name := container.name\r\n    not container.readinessProbe\r\n\r\n
    \   # Build message to return\r\n    msg = sprintf(\"[FAIL] %v - Readiness Probe
    missing for container \\\"%v\\\" (%v)\", [policy_metadata.severity, name, policy_metadata.errcode])\r\n\r\n
    \   info := {\r\n\r\n        \"name\": policy_metadata.name,\r\n        \"severity\":
    policy_metadata.severity,\r\n        \"errcode\": policy_metadata.errcode,\r\n
    \       \"msg\": msg,\r\n\r\n    }\r\n\r\n}\r\n\r\n# find_containers accepts a
    value (k8s object type) and returns the container spec\r\nfind_containers(type,
    metadata) = input.request.object.spec.containers {\r\n\r\n    type == \"Pod\"\r\n\r\n}
    else = input.request.object.spec.template.spec.containers {\r\n\r\n\tmetadata.targets[type]\r\n
    \   \r\n}"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-readiness-probe-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-resource-limits-check.rego: "package kubernetes.admission.policy_resource_limits\r\n\r\npolicy_metadata
    = {\r\n\r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-resource-limits\",\r\n
    \   \"severity\": \"LOW\",\r\n    \"errcode\": \"MT1003\",\r\n    \"targets\":
    {\"Deployment\", \"StatefulSet\", \"DaemonSet\", \"Pod\"},\r\n\r\n}\r\n\r\nservicetype
    = input.request.kind.kind\r\n\r\nmatches {\r\n\r\n    # Verify request object
    type matches targets\r\n    policy_metadata.targets[servicetype]\r\n    \r\n}\r\n\r\ndeny[info]
    {\r\n\r\n    # Find container spec\r\n    containers := find_containers(servicetype,
    policy_metadata)\r\n\r\n    # Check for livenessProbe in container spec\r\n    container
    := containers[_]\r\n    name := container.name\r\n    resource_type := get_resource_type(container)\r\n\r\n
    \   # Build message to return\r\n    msg = sprintf(\"[FAIL] %v - Resource limits
    missing (%v) for container \\\"%v\\\" (%v)\", [policy_metadata.severity, resource_type,
    name, policy_metadata.errcode])\r\n\r\n    info := {\r\n\r\n        \"name\":
    policy_metadata.name,\r\n        \"severity\": policy_metadata.severity,\r\n        \"errcode\":
    policy_metadata.errcode,\r\n        \"msg\": msg,\r\n\r\n    }\r\n\r\n}\r\n\r\n#
    find_containers accepts a value (k8s object type) and returns the container spec\r\nfind_containers(type,
    metadata) = input.request.object.spec.containers {\r\n\r\n    type == \"Pod\"\r\n\r\n}
    else = input.request.object.spec.template.spec.containers {\r\n\r\n\tmetadata.targets[type]\r\n
    \   \r\n}\r\n\r\n# get_resource_type accepts a value (containers) and returns
    the missing resource type based on missing limits\r\nget_resource_type(container)
    = \"CPU/MEM\" {\r\n\r\n    not container.resources.limits.cpu\r\n    not container.resources.limits.memory\r\n
    \   \r\n} else = \"CPU\" {\r\n\t\r\n    not container.resources.limits.cpu\r\n
    \   \r\n} else = \"MEM\" {\r\n\t\r\n    not container.resources.limits.memory\r\n
    \   \r\n}"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-resource-limits-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-resource-requests-check.rego: "package kubernetes.admission.policy_resource_requests\r\n\r\npolicy_metadata
    = {\r\n\r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-resource-requests\",\r\n
    \   \"severity\": \"LOW\",\r\n    \"errcode\": \"MT1004\",\r\n    \"targets\":
    {\"Deployment\", \"StatefulSet\", \"DaemonSet\", \"Pod\"},\r\n\r\n}\r\n\r\nservicetype
    = input.request.kind.kind\r\n\r\nmatches {\r\n\r\n    # Verify request object
    type matches targets\r\n    policy_metadata.targets[servicetype]\r\n    \r\n}\r\n\r\ndeny[info]
    {\r\n\r\n    # Find container spec\r\n    containers := find_containers(servicetype,
    policy_metadata)\r\n\r\n    # Check for livenessProbe in each container spec\r\n
    \   container := containers[_]\r\n    name := container.name\r\n    resource_type
    := get_resource_type(container)\r\n\r\n    # Build message to return\r\n    msg
    := sprintf(\"[FAIL] %v - Resource requests missing (%v) for container \\\"%v\\\"
    (%v)\", [policy_metadata.severity, resource_type, name, policy_metadata.errcode])\r\n\r\n
    \   info := {\r\n\r\n        \"name\": policy_metadata.name,\r\n        \"severity\":
    policy_metadata.severity,\r\n        \"errcode\": policy_metadata.errcode,\r\n
    \       \"msg\": msg,\r\n\r\n    }\r\n    \r\n}\r\n\r\n# find_containers accepts
    a value (k8s object type) and returns the container spec\r\nfind_containers(type,
    metadata) = input.request.object.spec.containers {\r\n\r\n    type == \"Pod\"\r\n\r\n}
    else = input.request.object.spec.template.spec.containers {\r\n\r\n\tmetadata.targets[type]\r\n
    \   \r\n}\r\n\r\n# get_resource_type accepts a value (containers) and returns
    the missing resource type based on missing limits\r\nget_resource_type(container)
    = \"CPU/MEM\" {\r\n\r\n    not container.resources.requests.cpu\r\n    not container.resources.requests.memory\r\n
    \   \r\n} else = \"CPU\" {\r\n\t\r\n    not container.resources.requests.cpu\r\n
    \   \r\n} else = \"MEM\" {\r\n\t\r\n    not container.resources.requests.memory\r\n
    \   \r\n}"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-resource-requests-check
  namespace: magtape-system
---

apiVersion: v1
data:
  policy-singleton-pod-check.rego: "package kubernetes.admission.policy_singleton_pod_check\r\n\r\npolicy_metadata
    = {\r\n\r\n    # Set MagTape Policy Info\r\n    \"name\": \"policy-singleton-pod-check\",\r\n
    \   \"severity\": \"LOW\",\r\n    \"errcode\": \"MT1007\",\r\n    \"targets\":
    {\"Pod\"},\r\n\r\n}\r\n\r\nkind = input.request.kind.kind\r\n\r\nmatches {\r\n\r\n
    \   # Verify request object type matches targets\r\n    policy_metadata.targets[kind]\r\n\r\n}\r\n\r\ndeny[info]
    {\r\n\r\n    name := input.request.object.metadata.name\r\n\r\n    # Check for
    ownerReferences, will only be present if something is dependent on the Pod\r\n
    \   not input.request.object.metadata.ownerReferences\r\n\r\n    # Build message
    to return\r\n    msg := sprintf(\"[FAIL] %v - \\\"%v\\\" is a singleton pod. (%v)\",
    [policy_metadata.severity, name, policy_metadata.errcode])\r\n\r\n    info :=
    {\r\n\r\n        \"name\": policy_metadata.name,\r\n        \"severity\": policy_metadata.severity,\r\n
    \       \"errcode\": policy_metadata.errcode,\r\n        \"msg\": msg,\r\n\r\n
    \   }\r\n}\r\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  labels:
    app: opa
    openpolicyagent.org/policy: rego
  name: policy-singleton-pod-check
  namespace: magtape-system
---

